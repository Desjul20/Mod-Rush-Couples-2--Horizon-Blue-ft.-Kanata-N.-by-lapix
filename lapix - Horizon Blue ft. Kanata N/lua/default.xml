<ActorFrame
InitCommand="%function(self)
	nitg_version = FUCK_EXE and tonumber(GAMESTATE:GetVersionDate()) >= 20200112 --NotITG version number to check for, v3 by default
	--the notitg build date is at minimum of v4
	
	if not nitg_version then
		SCREENMAN:SystemMessage('Outdated version of NotITG detected, mods will not work');
	end
	
	songName = GAMESTATE:GetCurrentSong():GetSongDir();
	
	m_bl = 60/145 --use this to define length of a beat for use in the rest of the song
	sw = SCREEN_WIDTH
	sh = SCREEN_HEIGHT --shortcuts
	
	function Plr(pn)
		return _G['P'..pn]
	end
	
	function mod_do(str,pn)
		if pn then
			GAMESTATE:ApplyGameCommand('mod,'..str,pn)
		else
			GAMESTATE:ApplyGameCommand('mod,'..str)
		end
	end
end"
><children><ActorFrame Condition="nitg_version"
OnCommand="%function(self)
	nvidia = false
	alphamult = 1
	if string.find(string.lower(PREFSMAN:GetPreference('LastSeenVideoDriver')), 'nvidia') or string.find(string.lower(DISPLAY:GetVendor()),'nvidia') then
		Trace('NVidia graphics driver detected.')
		Trace('AFT multiplier set to 0.9')
		nvidia = true
		alphamult = 0.9
	end
	if not string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl')
	or string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d')
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') 
	and string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'd3d') < 
	string.find(string.lower(PREFSMAN:GetPreference('VideoRenderers')), 'opengl') then
		SCREENMAN:SystemMessage('D3D Video Renderer detected. Expect textures to fail.');
	end
end"
><children>

	<Layer
		Type="Quad"
		InitCommand="hidden,1"
		OnCommand="sleep,1000"
	/>
	
	<Layer File="modhelpers" />
	<Layer File="easing" />
	<Layer File="spellcards" />
	<Layer File="../notedata.xml" />
	
	<Layer
		Type="ActorFrame"
		InitCommand="%function(self)
		
			checked = false;
		
			---------------------------------------------------------
			---------DOCUMENTATION-----------------------------------
			---------------------------------------------------------
			
			--function perframe( beat, endBeat )
				--return true if the current beat is between 'beat' and 'endBeat'
			
			--function mod_shader(beat,key,which)
				--turn on shader key at specified beat (up to 10 keys available, defined by 'which' = 0-9
				
			--function mod_insert(beat,len,mod,len_or_end,pn)
				--insert mod into beat mods table
			--function mod_insert2(time,len,mod,len_or_end,pn)
				--insert mod into time mods table
			--function mod_ease(beat, len, start_strength, end_strength, mod, len_or_end, ease_type, pn, sustain, opt1, opt2)
				--insert mod into ease mods table
			--function mod_perframe(start, end, function(beat, deltatime))
				--insert function into perframe reader
				
			--function mod_message(beat,msg,persistent)
				--insert something into the actions table.
				--msg can also be a function. If string, a message gets broadcast at that beat
				--if 'persistent' is true, message will run even if editor starts at a beat past it
				
			--function mod_blacklist(t,n)
				--check if number n occurs in table t
				--useful for doing 'every beat EXCEPT the contents of t'
				
			--function simple_m0d(beat,strength,mult,mod)
			--function simple_m0d2(beat,strength,mult,mod,pn)
			--function simple_m0d3(beat,strength,duration,bpm,mod,pn)
				--activate mods at specific beat but also deactivate them
				
			--function mod_wiggle(beat,num,div,amt,speed,mod,pn,first)
				--alternates a mod back and forth before resetting to 0
				
			--function mod_spring(beat,strength,num,mod,pn)
				--like mod_wiggle, but springier
			
			--function mod_springt(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod that decreases based on how much time is left.
					--think doorstopper
			
			--function mod_springt2(time,strength,dur,mod,pn)
				--time-based per-frame alternating mod
			
			--function mod_spring_adjustable(beat,strength,num,period,mod,pn, first)
				--it's not very good
			
			--function mod_beat(beat,strength,pn)
				--turns on beat for the beat specified, at the desired strength	
			
			--function switcheroo_add(beat,which,speed,len,pn)
				--adds a column swap at the desired beat
			--[[	switcheroos = {normal = {0,0}, ldur = {0,0}, reset = {0,0},
					flip = {100,0}, rudl = {100,0}, invert = {0,100}, dlru = {0,100},
					ludr = {25,-75}, rdul = {75,75}, drlu = {25,125}, ulrd = {75,-125}, urld = {100,-100}}
			]]
			
			--function mod_sugarkiller(beat,duration,speed,minstealth,maxstealth,pn)
				--portable version of the effect from sugarkill X
			
			--function mod_bounce(beat,length,start,apex,mod,ease_type,pn)
			--function func_bounce(beat,length,start,apex,function,ease_type)
				--eases out from start to apex, then eases back in from apex to start
				--ease_type should be a string, i.e. 'Quad', 'Cubic', 'Circ'
			
			
			
			--function modulo(a, b)
				--returns the remainder when a is divided by b, works properly with negatives unlike math.mod
			
			--function randomXD(t)
				--returns a pseudo-random number between 0 and 1 seeded based on the given argument
				--returns 0.5 if t is 0 (useful sometimes!)
				
			---------------------------------------------------------
			--------END DOCUMENTATION--------------------------------
			---------------------------------------------------------
			
			local linear, inQuad, outQuad, inOutQuad, outInQuad, inCubic, outCubic, inOutCubic, outInCubic, inQuart, outQuart, inOutQuart, outInQuart, inQuint, outQuint, inOutQuint, outInQuint, inSine, outSine, inOutSine, outInSine, inExpo, outExpo, inOutExpo, outInExpo, inCirc, outCirc, inOutCirc, outInCirc, inElastic, outElastic, inOutElastic, outInElastic, inBack, outBack, inOutBack, outInBack, inBounce, outBounce, inOutBounce, outInBounce = ease.linear, ease.inQuad, ease.outQuad, ease.inOutQuad, ease.outInQuad, ease.inCubic, ease.outCubic, ease.inOutCubic, ease.outInCubic, ease.inQuart, ease.outQuart, ease.inOutQuart, ease.outInQuart, ease.inQuint, ease.outQuint, ease.inOutQuint, ease.outInQuint, ease.inSine, ease.outSine, ease.inOutSine, ease.outInSine, ease.inExpo, ease.outExpo, ease.inOutExpo, ease.outInExpo, ease.inCirc, ease.outCirc, ease.inOutCirc, ease.outInCirc, ease.inElastic, ease.outElastic, ease.inOutElastic, ease.outInElastic, ease.inBack, ease.outBack, ease.inOutBack, ease.outInBack, ease.inBounce, ease.outBounce, ease.inOutBounce, ease.outInBounce
			
			init_modsp1 = '';
			init_modsp2 = '';
			
			mod_plr = {};
			
			mod_firstSeenBeat = GAMESTATE:GetSongBeat(); --necessary to prevent long freezes
			
			mod_lasttime = 0
			
			local m = mod_insert
			local m2 = mod_message
			local me = mod_ease
		    local mpf = mod_perframe
			P3 = SCREENMAN:GetTopScreen():GetChild('PlayerP3')
               if P3 then
            P3:SetAwake(false)
            P3:hidden(0)
            P3:SetInputPlayer(1)
			P3:GetChild('Judgment'):hidden(1)
			P3:GetChild('Combo'):hidden(1)
			P3:zoom(1.2)    
             end
			--dude. this P4 has been set to define P3 for a whole morning. how did I miss this???  
			P4 = SCREENMAN:GetTopScreen():GetChild('PlayerP4')
               if P4 then
            P4:SetAwake(false)
            P4:hidden(0)
            P4:SetInputPlayer(1)
			P4:GetChild('Judgment'):hidden(1)
			P4:GetChild('Combo'):hidden(1)
            end
			--this might come in handy     
			local function quickOn(beat,strength,len,md,pn)
			    local activation_rate = math.abs(strength/10)
			    m( beat-0.1,0.3,'*'..activation_rate..' '..strength..' '..md, 'len', pn )
				m( beat+0.1,len,'*'..((activation_rate/5)/len)..' 0 '..md, 'len', pn )
			end    
			
			
			
---------------------------------------------------------------------------------------
----------------------Begin tables 'n stuff--------------------------------------------
---------------------------------------------------------------------------------------
			--beat based mods
			--{beat_start, beat_end, mods, len_or_end, player_number}
			mods = {
				{0,9999,'*2 2.5x, *-1 overhead, *-1 approachtype, *-1 dizzyholds, *-1 stealthpastreceptors, *-1 modtimer, *-1 -999999999 cover','end'},	
				{0,30.5,'*0.25 35 tipsy, *0.25 35 drunk','len'},
				{30.5,1.5,'*0.25 0 tipsy, *0.25 0 drunk','len'},
				{36,13,'*0.25 50 tipsy, *0.25 50 drunk','len'},
				{49,13,'*0.25 0 tipsy, *0.25 0 drunk','len'},
				
				{260,99,'*-1 40 DrawSize','len'},
				
				{260,64,'*8 300 beat','len'},
			}
			
			--beat-based ease mods
			--{beat_start, beat_end, mod_start, mod_end, mod/function, len_or_end, ease_type, player_number, sustainbeats, optional_param1, optional_param2}
			--valid ease types are:
				--linear
				--inQuad    outQuad    inOutQuad    outInQuad
				--inCubic   outCubic   inOutCubic   outInCubic
				--inQuart   outQuart   inOutQuart   outInQuart
				--inQuint   outQuint   inOutQuint   outInQuint
				--inSine    outSine    inOutSine    outInSine
				--inExpo    outExpo    inOutExpo    outInExpo
				--inCirc    outCirc    inOutCirc    outInCirc
				--inElastic outElastic inOutElastic outInElastic    --can take 2 optional parameters - amplitude & period
				--inBack    outBack    inOutBack    outInBack       --can take 1 optional parameter  - spring amount
				--inBounce  outBounce  inOutBounce  outInBounce
				
			mods_ease = {
				-- EXAMPLE TWEEN: from beat 0 to 4, make rotationz go from 360 to 0 with the inOutBack tween
				--{0, 4, 360, 0, 'rotationz', 'len', inOutBack},
				{6,0.75,0,100,'flip','len',outQuad},
				{6.75,0.75,100,0,'flip','len',outQuad},
				{6.75,0.75,0,100,'invert','len',outQuad},
				{7.5,0.75,100,0,'invert','len',outQuad},
				
				{14,0.75,0,100,'invert','len',outQuad},
				{14.75,0.75,0,100,'flip','len',outQuad},
				{14.75,0.75,100,0,'invert','len',outQuad},
				{15.5,0.75,100,0,'flip','len',outQuad},
				
				{32,1,0,100,'flip','len', outCubic,3},
				{33,1,0,100,'invert','len', outCubic,3},
				{33,1,100,0,'flip','len', outCubic,3},
				{34,1,0,100,'flip','len', outCubic,3},
				{34,1,100,-100,'invert','len', outCubic,3},
				{35,1,100,0,'flip','len', outCubic,3},
				{35,1,-100,0,'invert','len', outCubic,3},
				
				{64,1,0,100,'flip','len', outCubic},
				{65,1,0,100,'invert','len', outCubic},
				{65,1,100,0,'flip','len', outCubic},
				{66,1,0,100,'flip','len', outCubic},
				{66,1,100,-100,'invert','len', outCubic},
				{67,1,100,0,'flip','len', outCubic},
				{67,1,-100,0,'invert','len', outCubic},
				
				{128,1,0,100,'flip','len', outCubic},
				{129,1,0,100,'invert','len', outCubic},
				{129,1,100,0,'flip','len', outCubic},
				{130,1,0,100,'flip','len', outCubic},
				{130,1,100,-100,'invert','len', outCubic},
				{131,1,100,0,'flip','len', outCubic},
				{131,1,-100,0,'invert','len', outCubic},
				
				{164,1,100,0,'stealth','len',outQuint},
				
				{165.5,1,100,0,'stealth','len',outQuint},
				
				{169.75,171.25,100,0,'stealth','end',inQuint},
				
				-- EXAMPLE TWEEN: from beat 4 to 8, rotate topscreen from 360 to 0 with the outBack tween
				--{4, 4, 360, 0, function(a) SCREENMAN:GetTopScreen():rotationz(a) end, 'len', outBack},
			}
			
			--time based mods
			mod_time = 0;
			--{time_start, time_end, mods, len_or_end, player_number}
			mods2 = {
			}
			
			-- you can now write perframe stuff without having to scroll down!
			-- {beat_start,beat_end,function(beat,deltatime)}
			mod_perframes = {
				--{18,24,function(beat,deltatime)
					-- do stuff every frame from beat 18-24
					-- print(beat,deltatime)
				--end},
			}
			
			--this is both a message broadcaster and a function runner
			--if you put {beat,'String'}, then 'String' is broadcast as a message on that beat
			--if you put {beat,function() somecode end}, then function() is run at that beat
			--see example on beat 0
			
			curaction = 1;
			--{beat,thing,persists}
			mod_actions = {
				{0,'GetProxy',true},
				{68,'DestroyBG',true},
				{340,'ResetBG',true},
				{404,'DestroyBG',true},
				{228,'Proxy',true},
				{324,'HideProxy',true},
				{0,function()
					for pn=1,2 do
						local a = Plr(pn)
						if a then
							a:GetChild('Judgment'):hidden(1)
							a:GetChild('Combo'):hidden(1)
							a:SetFarDist(10000)
						end
					end
					
					for pn=1,2 do
						local d = 0.25; if pn == 2 then d = 0.75 end
						local b = _G['jud'..pn..'p']
						if b then
							b:hidden(0);
							b:basezoomx(0.75);
							b:basezoomy(0.75);
							b:x(SCREEN_WIDTH*d)
							b:y(SCREEN_HEIGHT*0.5)
						end
						local c = _G['com'..pn..'p']
						if c then
							c:hidden(0);
							c:basezoomx(0.75);
							c:basezoomy(0.75);
							c:x(SCREEN_WIDTH*d)
							c:y(SCREEN_HEIGHT*0.5)
						end
					end
				end,true},
			}
			     
			m2(0, function()
			   for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
			    a:linear(0.001)
				a:zoom(0.01)
			    a:x(sw/2)
			    end
				end
			 end, true)
			 
			m2(2.5,function()
			   for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
			    a:accelerate(0.75)
				a:zoom(1)
			    end
				end
			 end, true)
			 
			 m2(4,function()
			   for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
			    a:bounce(1)
				a:effectmagnitude(0,10,0)
				a:effectperiod(0.5)
			    end
				end
			 end, true)
			     
			 m2(13,function()
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):linear(0.01)
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):diffusealpha(0)
			end)
			
			m2(29,function()
			   Plr(1):SetHiddenRegions({{32,36.1}})
			   Plr(2):SetHiddenRegions({{32,36.1}})
			end)
			
			m2(27,function()
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):x(800)
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):diffusealpha(0.4)
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):zoom(0.6)
			end)
			
			m2(30,function()
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):linear(3.5)
			SCREENMAN:GetTopScreen():GetChild('PlayerP3'):addx(-1000)
			end)
			
			m2(36,function()
			flash:accelerate(0.1)
			flash:diffusealpha(1)
			flash:accelerate(0.8)
			flash:diffusealpha(0)
			end)
			
			m2(36,function()
			gradient:accelerate(0.5)
			gradient:diffusealpha(0.5)
			end)
			
			m2(68,function()
			flash:diffusealpha(1)
			flash:accelerate(0.6)
			flash:diffusealpha(0)
			end)
			
			m2(36,function()
			--THIS IS NICE.
			blurizon:accelerate(0.1)
			blurizon:diffusealpha(1)
			end)     
			
			m2(68,function()
				--Removing for the transition to black
				blurizon:diffusealpha(0)
				gradient:accelerate(1.960)
				gradient:diffusealpha(0)
				for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
					a:stopeffect()
				end
				end
			end,true)
			
			--im sleepy and forgot the purpose of these, but ill still put them here
			m(0,3,'*-1 stealth','len')
			m(0,290.5,'*-1 stealth','len',4)
			m(0,3,'*-1 dark','len',3)
			m(30,1,'*-1 30% dark','len',3)
			m(0,3,'*-1 dark','len',4)
			     
			me(2.5,2.75,360,0,'rotationz','len',outCubic)
			m(0,3.5,'*-1 stealth','len')
			m(0,3,'*-1 dark','len',3)
			me(3,1.5,100,0,'stealth','len',outCubic)
			m(4,29,'*-1 80% stealth','len',3)
			m(29,4,'*1 no stealth','len',3)
			m(30.5,6,'*-1 30% stealth','len',3)
			me(28.5,0.5,0,30,'rotationy','len',outCubic,1)
			me(29,7,1110,0,'rotationy','len',outCubic,1)
			me(28.5,0.5,0,30,'rotationy','len',outCubic,2)
			me(29,7,1110,0,'rotationy','len',outCubic,2)
			me(28.5,0.5,0,30,'rotationy','len',outCubic,4)
			me(29,7,1110,0,'rotationy','len',outCubic,4)
			me(18,1,0,50,'movey','len',inOutElastic,1)
			me(18,1,0,-50,'movey','len',inOutElastic,2)
			me(19.5,2,360,0,'rotationx','len',outCubic)
			m(30.5,6,'*-1 85% stealth','len',3)
			
			m(224,258.25,'Dark,*-1 Halgun','end',1)
			m(224,258.25,'Dark,*-1 Halgun','end',2)
			m(225,259.75,'*-1 HideNoteFlash','end',1)
			m(225,259.75,'*-1 HideNoteFlash','end',2)
			m(259.75,0.25,'*-1 no HideNoteFlash','len')
			m(258.25,999,'Dark','len',3)
			m(258.25,999,'Dark','len',4)
			m(260,999,'*-1 hide,*-1 Halgun','len',3)
			m(260,999,'*-1 hide,*-1 Halgun','len',4)
			
			--I hope this doesn't lag too much. It's fine for me. Cool effect either way
			m(228,257.5,'*-1 -3000% parabolaz, *-1 200 drawsize','end')
			me(257.5,260,-3000,0,'parabolaz','end',inCubic,2)
			me(257.5,260,-3000,0,'parabolaz','end',inCubic,1)
			m(227,260,'*-1 0 parabolaz, *2 95 stealth, 150 wave, -100 tornado,  distant, 25 centered, dark','end',3)
			m(227,260,'*-1 0 parabolaz, *2 95 stealth, 150 wave, 100 tornado,  distant, 25 centered, dark','end',4)
			     --thinking about making a similar motion to windy fairy... don't have time to mod it right now though 
			me(36,5,0,-200,'movex0','len',outCubic,1)
			me(36,5,0,-100,'movex0','len',outCubic,2)
			me(36,5,0,-100,'movex1','len',outCubic,1)
			me(36,5,0,100,'movex2','len',outCubic,1)
			me(36,5,0,200,'movex3','len',outCubic,1)
			me(36,5,0,100,'movex3','len',outCubic,2)
			me(41,25,-200,-200,'movex0','len',outCubic,1)
			me(41,25,-100,-100,'movex0','len',outCubic,2)
			me(41,25,-100,-100,'movex1','len',outCubic,1)
			me(41,25,100,100,'movex2','len',outCubic,1)
			me(41,25,200,200,'movex3','len',outCubic,1)
			me(41,25,100,100,'movex3','len',outCubic,2)
			me(50.5,1,0,300,'pulse','len',outExpo)
			me(51.5,1.5,360,0,'rotationz','len',outExpo)
			m(36,20,'*-1 arrowpath','len')
			
			m(68,1,'*-1 no pulse, *-1 no arrowpath, *-1 no tiny','len')
			
			me(176,1,0,200,'expand','len',outQuint)
			me(177,1,200,0,'expand','len',inCirc)
			m(178,0.25,'*16 '..(math.rad(90)*100)..' ConfusionZOffset','len')
			m(178.25,0.25,'*16 '..(math.rad(180)*100)..' ConfusionZOffset','len')
			m(178.5,0.25,'*16 '..(math.rad(270)*100)..' ConfusionZOffset','len')
			m(178.75,0.5,'*16 '..(math.rad(360)*100)..' ConfusionZOffset','len')
			m(179.25,0.25,'*16 '..(math.rad(450)*100)..' ConfusionZOffset','len')
			m(179.5,0.25,'*16 '..(math.rad(540)*100)..' ConfusionZOffset','len')
			m(179.75,0.25,'*32 '..(math.rad(0)*100)..' ConfusionZOffset','len')
			
			m(228,260,'*-1 400 movex','end',1)
			m(260,261,'*-1 0 movex','end',1)
			
			
			
			
			me(100,0.5,0,100,'flip','len',outBack)
			me(100.5,0.5,100,0,'flip','len',outBack)
			me(101,0.25,0,200,'drunk','len',linear)
			me(101.25,0.25,200,-200,'drunk','len',linear)
			me(101.5,0.25,-200,0,'drunk','len',linear)
			m(101.75,0.25,'*16 1x, *32 400 bumpy, 25 dizzy, 50 tipsy','len')
			m(102,6,'*1.75 2.5x, *2 no bumpy, *1.5 no dizzy, *1.75 no tipsy','len')
			
			me(102.25,0.25,0,100,'invert','len', outCubic)
			me(102.5,0.5,100,75,'invert','len', outCubic)
			me(102.5,0.5,0,75,'flip','len', outCubic)
			me(103,0.5,75,-75,'invert','len', outCubic)
			me(103,0.5,75,25,'flip','len', outCubic)
			me(103.5,0.5,-75,0,'invert','len', outCubic)
			me(103.5,0.5,25,0,'flip','len', outCubic)
			
			me(104,0.5,0,100,'Reverse','len', outCubic)
			m(104.5,11.5,'*-1 Reverse')
			
			me(105,0.25,0,100,'invert','len',outBack)
			me(105.25,0.25,100,0,'invert','len',outBack)
			
			me(105.75,0.5,0,200,'drunk, tipsy','len',linear)
			me(106.25,0.25,200,-200,'drunk, tipsy','len',linear)
			me(106.5,0.25,-200,0,'drunk, tipsy','len',linear)
			
			me(107,0.25,0,100,'invert','len', outCubic)
			me(107.25,0.25,100,75,'invert','len', outCubic)
			me(107.25,0.25,0,75,'flip','len', outCubic)
			me(107.5,0.25,75,0,'flip','len', outCubic)
			me(107.5,0.25,75,0,'invert','len', outCubic)
			
			m(108,0.25,'*16 1x, *32 400 bumpy, 25 dizzy, 50 tipsy','len')
			m(108.25,6,'*1.75 2.5x, *2 no bumpy, *1.5 no dizzy, *1.75 no tipsy','len')
			
			me(109,0.25,0,200,'drunk, tipsy','len',linear)
			me(109.25,0.25,200,-200,'drunk, tipsy','len',linear)
			me(109.5,0.25,-200,0,'drunk, tipsy','len',linear)
			
			me(110.25,0.25,0,100,'invert','len', outCubic)
			me(110.5,0.25,100,75,'invert','len', outCubic)
			me(110.5,0.25,0,75,'flip','len', outCubic)
			me(110.75,0.25,75,0,'flip','len', outCubic)
			me(110.75,0.25,75,0,'invert','len', outCubic)
			
			me(111.25,0.25,0,200,'tipsy','len',outCubic)
			me(111.5,0.25,200,-200,'tipsy','len',outCubic)
			me(111.75,0.25,-200,0,'tipsy','len',outCubic)
			
			me(116,0.5,100,0,'Reverse','len', outCubic)
			m(116,1,'*-1 no Reverse')
			
			
			--can't just let the player 3 in the back move without wacky effects! not exactly satisfied with quickOn though.
			
			--yeah, at least you have something to go off of.
			for i=31,36, 1 do
			quickOn(i,50,.5,'tipsy',3)
			quickOn(i,50,.5,'drunk',3)
			quickOn(i+1,-100,.5,'tipsy',3)
			quickOn(i+1,-100,.5,'drunk',3)
			end
			
			m(100,99,'*-1 no stealth','len',3)
			     
			m2(260,function()
			 for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
				Plr(1):x(SCREEN_CENTER_X-192)
				a:zoom(0.75)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):addx(-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
			        --the cool horizon part im trying to make starts before these, so im commenting them out for now
				--[[a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(2)
				a:addx(192*2)
				a:sleep(0)
				a:x(SCREEN_CENTER_X)
				Plr(1):x(SCREEN_CENTER_X-192)
				a:linear(1.098)
				a:addx(192)
				a:sleep(0)
				a:zoom(1)]]
				
				
			    end
				end
			end, true)
			
			me(2.5,2.75,360,0,'rotationz','len',outCubic)
			m(0,3.5,'*-1 stealth','len')
			me(3,1.5,100,0,'stealth','len',outCubic)
			
			m2(112, function()
				aux_spin:linear(0.393/2) 
				aux_spin:aux(25)
			end,true)
			
			m2(115.5,function()
				aux_spin:linear(0.393/2) 
				aux_spin:aux(0)
			end,true)
			
			m2(143, function()
				aux_spin:linear(0.393/2) 
				aux_spin:aux(25)
			end,true)
			
			m2(147.5,function()
				aux_spin:linear(0.393/2) 
				aux_spin:aux(0)
			end,true)
			
			m2(225,function()
				Plr(1):SetHiddenRegions({{225,259.75}})
				Plr(2):SetHiddenRegions({{225,259.75}})
				for pn = 1, 2 do
			    local a = Plr(pn)
			    if a then
					Plr(1):x(SCREEN_CENTER_X-192)
					a:zoom(0.75)
					SCREENMAN:GetTopScreen():GetChild('PlayerP3'):SetHiddenRegions({{260,324}})
					SCREENMAN:GetTopScreen():GetChild('PlayerP4'):SetHiddenRegions({{260,324}})
				end
				end
			end,true)
			
			m2(53.5,function()
				aux:linear(0.393*12)
				aux:aux(150)
			end,true)
			
			--trivial, but adds a nice touch to the bg.     
			mpf(36,68,function(beat)
				blurizon:rotationy( 5*math.sin(beat*math.pi) )
				blurizon:rotationx( 5*math.sin(beat*math.pi) )
			end)
			    
			     --I havent started modding this idea yet, but I'm thinking of making something similar to that one part in kirby's sea of white elephants file on 292 onwards. what do you think? 
				 
				 
					--I don't know what part but i think it's the part where the play field turns into a SDVX playfield. if it's that one then it'll fit but is kinda boring. I was thinking to still have the scrolling but more effects, i'm not sure if it is good to have the scrolling on that part.
				 
				 
				 
				 
			     --also, I dont have much ideas for the middle (100 to 226), so if you have anything cool for that part feel free to do it
				 
				 
					--Already working on it. Is gonna be difficult. I also helped you with some of the work you tried to add, it's not fully finished.. I hope it's what you want it to be.
				 
				 --orange notes: just curious, where are you from and how old are you? we've been working together for quite some time and I still know almost nothing about you
				
					--I'm from Arizona (United States). i'm 13.
---------------------------------------------------------------------------------------
----------------------Sort the actions table-------------------------------------------
---------------------------------------------------------------------------------------
			
			function modtable_compare(a,b)
				return a[1] < b[1]
			end
			
			if table.getn(mod_actions) > 1 then
				table.sort(mod_actions, modtable_compare)
			end
			
			self:luaeffect('Update')
		end"
		
		UpdateCommand="%function(self)
			local beat = GAMESTATE:GetSongBeat()
			
			function math.sign(v)
					return (v >= 0 and 1) or -1
				end
				function math.round(v, bracket)
					bracket = bracket or 1
					return math.floor(v/bracket + math.sign(v) * 0.5) * bracket
				end
			
			if beat>=0 and not checked then
					local ThingsToGrab = {'BPMDisplay','LifeFrame','ScoreFrame','Lyrics','SongBackground','SongForeground','Overlay','Underlay'}
					local ThingsToHide = {'BPMDisplay','LifeFrame','ScoreFrame','Overlay','Underlay'}
					for pn=1,2 do
						_G['P'..pn] = SCREENMAN:GetTopScreen():GetChild('PlayerP'..pn) or nil;
						if _G['P'..pn] then
							table.insert(mod_plr, _G['P'..pn])
							_G['jud'..pn]=_G['P'..pn]:GetChild('Judgment');
							_G['com'..pn]=_G['P'..pn]:GetChild('Combo');
							_G['jud'..pn]:hidden(1)
							_G['com'..pn]:hidden(1)
						end
						table.insert(ThingsToGrab,'LifeP'..pn); table.insert(ThingsToGrab,'ScoreP'..pn);
						table.insert(ThingsToHide,'LifeP'..pn); table.insert(ThingsToHide,'ScoreP'..pn);
					end	
					for i,v in ipairs(ThingsToGrab) do _G[v] = SCREENMAN:GetTopScreen():GetChild(v) or nil end	
					for i,v in ipairs(ThingsToHide) do if _G[v] then _G[v]:hidden(1) end end
				checked = true;
			end
			mod_curtime = GAMESTATE:GetSongTime()
			local deltatime = mod_curtime - mod_lasttime
			mod_lasttime = mod_curtime
			
---------------------------------------------------------------------------------------
----------------------Begin table handlers---------------------------------------------
---------------------------------------------------------------------------------------
			
			disable = false;
			if disable ~= true and checked then
				if beat > mod_firstSeenBeat+0.1 then -- performance coding!! --
					-----------------------
					-- Player mod resets --
					-----------------------
					for i=1,2 do
						GAMESTATE:ApplyModifiers('clearall',i)
						if _G['init_modsp'..i] then 
							GAMESTATE:ApplyModifiers(_G['init_modsp'..i],i)
						end
					end
				
					------------------------------------------------------------------------------
					-- custom mod reader by TaroNuke edited by WinDEU and re-stolen by TaroNuke --
					------------------------------------------------------------------------------
					for i,v in pairs(mods) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if beat >=v[1] then
								if (v[4] == 'len' and beat <=v[1]+v[2]) or (v[4] == 'end' and beat <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = '';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in beat-based table (line '..i..')');
						end
					end
				
					-----------------------------------------------------------------------------------------------------
					-- WinDEU's time-based len/end version of the #swag custom mod reader #teamproofofconcept (c) 2015 --
					-----------------------------------------------------------------------------------------------------
					for i,v in pairs(mods2) do
						if v and table.getn(v) > 3 and v[1] and v[2] and v[3] and v[4] then
							if mod_time >=v[1] then
								if (v[4] == 'len' and mod_time <=v[1]+v[2]) or (v[4] == 'end' and mod_time <=v[2]) then
									if table.getn(v) == 5 then
										GAMESTATE:ApplyModifiers(v[3],v[5]);
									else
										GAMESTATE:ApplyModifiers(v[3]);
									end
								end
							end
						else
							v[1] = 0;
							v[2] = 0;
							v[3] = 'error';
							v[4] = 'error';
							SCREENMAN:SystemMessage('Bad mod in time-based table (line '..i..')');
						end
					end
				
					---------------------------------------
					-- Ease table (includes func_ease) --
					---------------------------------------
					for i,v in pairs(mods_ease) do
						if v and table.getn(v) > 6 and v[1] and v[2] and v[3] and v[4] and v[5] and v[6] and v[7] then
							if beat >=v[1] then
								if (v[6] == 'len' and beat <=v[1]+v[2]) or (v[6] == 'end' and beat <=v[2]) then
									local strength = v[7](beat - v[1], v[3], v[4] - v[3], v[6] == 'end' and v[2] - v[1] or v[2], v[10], v[11])
									if type(v[5]) == 'string' then
										local modstr = v[5] == 'xmod' and strength..'x' or (v[5] == 'cmod' and 'C'..strength or strength..' '..v[5])
										GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
									elseif type(v[5]) == 'function' then
										v[5](strength)
									end
								elseif (v[9] and ((v[6] == 'len' and beat <=v[1]+v[2]+v[9]) or (v[6] == 'end' and beat <=v[9]))) then
									if type(v[5]) == 'string' then
										local modstr = v[5] == 'xmod' and v[4]..'x' or (v[5] == 'cmod' and 'C'..v[4] or v[4]..' '..v[5])
										GAMESTATE:ApplyModifiers('*9999 '..modstr,v[8]);
									elseif type(v[5]) == 'function' then
										v[5](v[4])
									end
								end
							end
						else
							SCREENMAN:SystemMessage('Ease Error! (line '..i..' | beat: '.. v[1] .. ' | mod: '.. v[5] ..')');
						end
					end
				
					---------------------
					-- Perframe reader --
					---------------------
					if table.getn(mod_perframes)>0 then
						for i=1,table.getn(mod_perframes) do
							local a = mod_perframes[i]
							if beat > a[1] and beat < a[2] then
								a[3](beat,deltatime);
							end
						end
					end
					
					if beat >= 111 then
							SCREENMAN:GetTopScreen():GetChild('PlayerP3'):zoom(1)
							Plr(1):x(aux_spin:getaux()*math.cos(beat * math.pi)+SCREEN_CENTER_X)
							Plr(1):y(aux_spin:getaux()*math.sin(beat * math.pi)+SCREEN_CENTER_Y)
							Plr(2):x(aux_spin:getaux()*math.cos((beat + 0.66666) * math.pi)+SCREEN_CENTER_X)
							Plr(2):y(aux_spin:getaux()*math.sin((beat + 0.66666) * math.pi)+SCREEN_CENTER_Y)
							SCREENMAN:GetTopScreen():GetChild('PlayerP3'):zoom(1)
							mod_do('*-1 0 mini')
							SCREENMAN:GetTopScreen():GetChild('PlayerP3'):x(aux_spin:getaux()*math.cos((beat + 1.33333) * math.pi)+SCREEN_CENTER_X)
							SCREENMAN:GetTopScreen():GetChild('PlayerP3'):y(aux_spin:getaux()*math.sin((beat + 1.33333) * math.pi)+SCREEN_CENTER_Y)
							mod_do('*-1 '..(math.abs(math.sin(beat/2 * math.pi)*(aux_spin:getaux()*4)))..' Invert')
					end
					
					if beat >= 292 and beat <= 324 then
						mod_do('*-1 '..(math.sin(beat/4 * math.pi)*100)..' drunk')
					end
					
					--Modified to be a flicker on tiny from a function I made for Pon-Pon-Pompoko Dai-Sen-Saw! It used to be a function on Blink but more controllable to be way better.
					
					function tinyFlicker(b,value1,value2,length,period,speed1,speed2)
						if beat-b < length then
							if ((beat-b)*period-(length-(length-math.round((beat-b)*period)))) > -0.5 and ((beat-b)*period-(length-(length-math.round((beat-b)*period)))) < 0 then
									mod_do('*'..speed1..' '..value1..' tiny')
							elseif ((beat-b)*period-(length-(length-math.round((beat-b)*period)))) > 0 and ((beat-b)*period-(length-(length-math.round((beat-b)*period)))) < 0.5 then
								mod_do('*'..speed2..' '..value2..' tiny')
							end
						end
					end
					
					tinyFlicker(53.5,aux:getaux(),aux:getaux()*-1,10.5,32,-1,-1)
				
					---------------------------------------
					-- Actions table --
					---------------------------------------
					while curaction<=table.getn(mod_actions) and GAMESTATE:GetSongBeat()>=mod_actions[curaction][1] do
						if mod_actions[curaction][3] or GAMESTATE:GetSongBeat() < mod_actions[curaction][1]+2 then
							if type(mod_actions[curaction][2]) == 'function' then
								mod_actions[curaction][2]()
							elseif type(mod_actions[curaction][2]) == 'string' then
								MESSAGEMAN:Broadcast(mod_actions[curaction][2]);
							end
						end
						curaction = curaction+1;
					end
				end
			end
---------------------------------------------------------------------------------------
----------------------END DON'T TOUCH IT KIDDO-----------------------------------------
---------------------------------------------------------------------------------------
			
		end"
		
	/>
	
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) judc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Judgment')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) jud2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Judgment')) end end"/>
	</children></ZZLAER>
	<ZZLAER Type="ActorFrame" InitCommand="%function(self) comc = self end"><children>
	<LAER Type="ActorProxy" InitCommand="%function(self) com1p = self end"
	GetProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1:GetChild('Combo')) end end"/>
	<LAER Type="ActorProxy" InitCommand="%function(self) com2p = self end"
	GetProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2:GetChild('Combo')) end end"/>
	</children></ZZLAER>
	
	
	<!--This is for the time based mod reader-->
	<BitmapText
		Font="Common Normal"
		Text="test"
		OnCommand="x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;effectclock,music;playcommand,SetTime;hidden,1"
		SetTimeCommand="%function(self) self:settext(self:GetSecsIntoEffect()); mod_time = tonumber(self:GetText()); self:sleep(0.02); self:queuecommand('SetTime'); end"
	/>
	
	<Layer
        Type="Sprite"
        Texture="transparent"
        OnCommand="%function(self)
            aftSpriteInfinite = self;
            self:basezoomx((SCREEN_WIDTH/DISPLAY:GetDisplayWidth()));
            self:basezoomy(-1*(SCREEN_HEIGHT/DISPLAY:GetDisplayHeight()))
            self:x(SCREEN_CENTER_X);
            self:y(SCREEN_CENTER_Y);
			self:diffusealpha(0)
            -- Set this like you want
			self:sleep(26.676)
			self:linear(0.392)
            self:zoom(1.05);
            self:diffusealpha(0.95*alphamult);
			self:decelerate(1.960)
			self:zoom(1.0);
			self:sleep(0);
            self:diffusealpha(0*alphamult);
        end"
    />
	
	<Layer
        Type="ActorFrameTexture"
        OnCommand="%function(self)
            infiniteAft = self;
            self:SetWidth(DISPLAY:GetDisplayWidth());
            self:SetHeight(DISPLAY:GetDisplayHeight());
            self:EnableDepthBuffer(false);
            self:EnableAlphaBuffer(true);
            self:EnableFloat(false);
            self:EnablePreserveTexture(true);
            self:Create();
            aftSpriteInfinite:SetTexture(self:GetTexture()); -- Put the texture into the sprite above.
            
        end"
    />
	
	<Layer
        Type="ActorFrameTexture"
        OnCommand="%function(self)
            NormalScreen = self;
            self:SetWidth(DISPLAY:GetDisplayWidth());
            self:SetHeight(DISPLAY:GetDisplayHeight());
            self:EnableDepthBuffer(false);
            self:EnableAlphaBuffer(true);
            self:EnableFloat(false);
            self:EnablePreserveTexture(true);
            self:Create();
        end"
    />
	
	
	
	----OPTIMIZE!!!!
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) self:x(192*4) end end"
	HideProxyMessageCommand="hidden,1" />
	
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) self:x(192*2) end end"
	HideProxyMessageCommand="hidden,1" />
	
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) self:x(192*3) end end"
	HideProxyMessageCommand="hidden,1" />
	
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) self:x(-192*2) end end"
	HideProxyMessageCommand="hidden,1" />
	
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P2 then self:SetTarget(P2) self:x(-192*2) end end"
	HideProxyMessageCommand="hidden,1" />
	
	<Layer Type="ActorProxy" 
	ProxyMessageCommand="%function(self) if P1 then self:SetTarget(P1) self:x(-192*3) end end"
	HideProxyMessageCommand="hidden,1" />
	
	
	
	<Layer Type="Quad" InitCommand="hidden,1;" OnCommand="%function(self) aux_spin = self self:aux(0) end" />
	
	<Layer Type="Quad" InitCommand="hidden,1;" OnCommand="%function(self) aux = self self:aux(5) end" />
	
	<Layer Type="Quad" InitCommand="diffusealpha,0;x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;" ResetBGMessageCommand="diffusealpha,1;zoomto,640,480;hidden,0;accelerate,0.6;diffusealpha,0" DestroyBGMessageCommand="diffusealpha,1;zoomto,640,480;hidden,0;accelerate,0.6;diffusealpha,0" />
	
	
	--<Layer Type="Quad" InitCommand="diffusealpha,0;x,SCREEN_CENTER_X;y,SCREEN_CENTER_Y;" ResetBGMessageCommand="diffusealpha,1;zoomto,640,480;hidden,0;accelerate,0.6;diffusealpha,0" DestroyBGMessageCommand="diffusealpha,1;zoomto,640,480;hidden,0;accelerate,0.6;diffusealpha,0" />
	
	--the flash above, but better
	<Layer
	Type="Quad"
	OnCommand="%function(self)
	flash=self;
	 self:diffusealpha(0);
         self:zoomto(SCREEN_WIDTH,SCREEN_HEIGHT);
           self:x(SCREEN_CENTER_X);
            self:y(SCREEN_CENTER_Y);
            self:diffuse(1,1,1,0);
	end"
	/>
	
	--im stealing a bunch of assets from other people's files so that I could get good graphics in our file, and honestly? it works, it works very well, it looks really good and it's only the beggining
	<Layer
	File="sparklies/gradient"
	OnCommand="%function(self)
	gradient=self;
	self:x(SCREEN_CENTER_X);
	self:y(SCREEN_CENTER_Y);
	self:diffusealpha(0)
	end"
	/>
	
	<Layer
	File="sparklies/white"
	OnCommand="%function(self)
	horizon=self
	self:zoomto(SCREEN_WIDTH,SCREEN_HEIGHT);
	self:x(SCREEN_CENTER_X);
	self:y(SCREEN_CENTER_Y);
	self:diffuse(0,0.5,2,0.5);
	self:sleep(26.676)
	self:linear(1.960)
	self:diffusealpha(0)
    end"
	/>
	
</children></ActorFrame></children></ActorFrame>
